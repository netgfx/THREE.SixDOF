import{Object3D as e,ShaderMaterial as t,BackSide as r,SphereBufferGeometry as i,NearestFilter as s,LinearFilter as o,RGBAFormat as a,SRGBColorSpace as u,Points as n,Mesh as p}from"three";var l={colorTexture:{type:"t",value:null},depthTexture:{type:"t",value:null},time:{type:"f",value:0},opacity:{type:"f",value:1},pointSize:{type:"f",value:3},debugDepth:{type:"f",value:0},displacement:{type:"f",value:1}},h=function(e){return e[e.LOW=64]="LOW",e[e.MEDIUM=128]="MEDIUM",e[e.HIGH=256]="HIGH",e[e.EXTRA_HIGH=512]="EXTRA_HIGH",e[e.EPIC=1024]="EPIC",e}(h||{}),m=function(e){return e[e.WIRE=0]="WIRE",e[e.POINTS=1]="POINTS",e[e.MESH=2]="MESH",e}(m||{}),v=function(e){return e[e.TOP_BOTTOM=0]="TOP_BOTTOM",e[e.SEPERATE=1]="SEPERATE",e}(v||{});class f{constructor(){this.type=v.SEPERATE,this.density=h.HIGH,this.style=m.MESH,this.displacement=4,this.radius=6}}class c extends e{constructor(e,i,s){super(),this.props=new f,this.material=new t({uniforms:l,vertexShader:"#define GLSLIFY 1\nvec3 getDepth(sampler2D depth,vec2 uvs){return texture2D(depth,uvs).rgb;}vec3 getDepthFromBottomHalf(sampler2D tex,vec2 uvs){vec2 lower_half_uvs=vec2(uvs.x,uvs.y*0.5);return texture2D(tex,lower_half_uvs).rgb;}uniform sampler2D colorTexture;uniform sampler2D depthTexture;uniform float pointSize;uniform float displacement;varying vec2 vUv;float depth;void main(){vUv=uv;gl_PointSize=pointSize;\n#ifdef TOP_BOTTOM\ndepth=getDepthFromBottomHalf(colorTexture,vUv).r;\n#endif\n#ifdef SEPERATE\ndepth=getDepth(depthTexture,vUv).r;\n#endif\nfloat disp=displacement*depth;vec3 offset=position+(-normal)*disp;gl_Position=projectionMatrix*modelViewMatrix*vec4(offset,1.0);}",fragmentShader:"#define GLSLIFY 1\nvec3 getDepth(sampler2D depth,vec2 uvs){return texture2D(depth,uvs).rgb;}vec3 getDepthFromBottomHalf(sampler2D tex,vec2 uvs){vec2 lower_half_uvs=vec2(uvs.x,uvs.y*0.5);return texture2D(tex,lower_half_uvs).rgb;}vec3 getColorFromUpperHalf(sampler2D tex,vec2 uvs){vec2 upper_half_uvs=vec2(uvs.x,(uvs.y*0.5)+0.5);return texture2D(tex,upper_half_uvs).rgb;}uniform sampler2D colorTexture;uniform sampler2D depthTexture;uniform float debugDepth;uniform float opacity;varying vec2 vUv;vec3 depth;vec3 color;void main(){\n#ifdef TOP_BOTTOM\ndepth=getDepthFromBottomHalf(colorTexture,vUv);color=getColorFromUpperHalf(colorTexture,vUv);\n#endif\n#ifdef SEPERATE\ndepth=getDepth(depthTexture,vUv);color=texture2D(colorTexture,vUv).rgb;\n#endif\nvec3 depthColorMixer=mix(color,depth,debugDepth);gl_FragColor=vec4(depthColorMixer,opacity);}",transparent:!0,side:r}),this.setProps(this.props,s),this.setShaderDefines(this.material,[v[this.props.type]]),c.geometry||(c.geometry=this.createSphereGeometry(this.props.radius,this.props.density)),this.assignTexture(this.props.type,e,i),this.displacement=this.props.displacement,super.add(this.createMesh(c.geometry,this.material,this.props.style))}setShaderDefines(e,t){t.forEach((function(t){return e.defines[t]=""}))}createSphereGeometry(e,t){return new i(e,t,t)}setProps(e,t){if(t)for(var r in t)e[r]?e[r]=t[r]:console.warn("THREE.SixDOF: Provided ".concat(r," in config but it is not a valid property and being ignored"))}assignTexture(e,t,r){if(e===v.SEPERATE){if(!r)throw new Error("When using seperate texture type, depthmap must be provided");this.depth=this.setDefaultTextureProps(r)}this.texture=this.setDefaultTextureProps(t)}setDefaultTextureProps(e){return e.minFilter=s,e.magFilter=o,e.format=a,e.colorSpace=u,e.generateMipmaps=!1,e}createMesh(e,t,r){switch(r){case m.WIRE:return this.material.wireframe||(this.material.wireframe=!0),new p(e,t);case m.MESH:return this.material.wireframe&&(this.material.wireframe=!1),new p(e,t);case m.POINTS:return new n(e,t)}}toggleDepthDebug(e){this.material.uniforms.debugDepth.value=null!=e?e:!this.material.uniforms.debugDepth.value}set displacement(e){this.material.uniforms.displacement.value=e}set depth(e){this.material.uniforms.depthTexture.value=e}set texture(e){this.material.uniforms.colorTexture.value=e}set opacity(e){this.material.uniforms.opacity.value=e}set pointSize(e){this.material.uniforms.pointSize.value=e}get config(){return this.props}get opacity(){return this.material.uniforms.opacity.value}get pointSize(){return this.material.uniforms.pointSize.value}get displacement(){return this.material.uniforms.displacement.value}get texture(){return this.material.uniforms.colorTexture.value}get depth(){return this.material.uniforms.opacity.value}}c.geometry=void 0;export{h as MeshDensity,m as Style,v as TextureType,c as Viewer};
//# sourceMappingURL=three-6dof.esm.min.js.map
